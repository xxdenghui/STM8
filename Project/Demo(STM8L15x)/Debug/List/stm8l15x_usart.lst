###############################################################################
#
# IAR C/C++ Compiler V3.10.1.201 for STM8                 22/Mar/2019  11:20:54
# Copyright 2010-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  
#        G:\Darren\MCU\STM8\Software\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_usart.c
#    Command line =  
#        -f C:\Users\new06\AppData\Local\Temp\EWB2F8.tmp
#        (G:\Darren\MCU\STM8\Software\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_usart.c
#        -e -On --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model small --data_model medium -o
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\Debug\Obj"
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\stm8\LIB\dlstm8smn.h" -D STM8L15 -lCN
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\Debug\List" -lB
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\Debug\List" -I
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\..\..\Libraries\STM8L15x_StdPeriph_Driver\inc\"
#        -I
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\..\..\Libraries\Device\"
#        -I
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\..\..\Libraries\HAL\"
#        -I
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\..\..\Libraries\Bus\"
#        -I
#        "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\..\..\Libraries\CRC\"
#        -I "G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\User\" --vregs
#        16)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\Debug\List\stm8l15x_usart.lst
#    Object file  =  
#        G:\Darren\MCU\STM8\Software\Project\Demo(STM8L15x)\Debug\Obj\stm8l15x_usart.o
#
###############################################################################

G:\Darren\MCU\STM8\Software\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - Half-duplex mode
     14            *           - Smartcard mode
     15            *           - IrDA mode
     16            *           - DMA transfers management
     17            *           - Interrupts and flags management 
     18            *           
     19            *  @verbatim
     20            *      
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          1. Enable peripheral clock using CLK_PeripheralClockConfig(CLK_Peripheral_USARTx,
     25            *             ENABLE) function (Refer to the product datasheet for the available USART
     26            *           	peripherals)
     27            *
     28            *          2.  Enable the external Pull-up on the used USART Pins using the
     29            *              GPIO_ExternalPullUpConfig() function or an external pull-up equivalent resistor
     30          	*              (RPU = 45 KOhm typical value). 
     31          	*
     32            *          3. Program the Baud Rate, Word Length , Stop Bit, Parity and Mode (Receiver/Transmitter)
     33            *           	using the USART_Init() function.
     34            *
     35            *          4. For synchronous mode, enable the clock and program the polarity,
     36            *             phase and last bit using the USART_ClockInit() function.
     37            *
     38            *          5. Enable the corresponding interrupt using the function USART_ITConfig() if you need 
     39          	*             to use interrupt mode. 
     40            *
     41            *          6. When using the DMA mode 
     42            *                   - Configure the DMA using DMA_Init() function
     43            *                   - Activate the needed channel Request using USART_DMACmd() function
     44            * 
     45            *          7. Enable the USART using the USART_Cmd() function.
     46            * 
     47            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     48            *
     49            *          Refer to Multi-Processor, half-duplex, Smartcard, IrDA sub-sections for more details.
     50            *          
     51            *  @endverbatim
     52            *        
     53            ******************************************************************************
     54            * @attention
     55            *
     56            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     57            *
     58            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     59            * You may not use this file except in compliance with the License.
     60            * You may obtain a copy of the License at:
     61            *
     62            *        http://www.st.com/software_license_agreement_liberty_v2
     63            *
     64            * Unless required by applicable law or agreed to in writing, software 
     65            * distributed under the License is distributed on an "AS IS" BASIS, 
     66            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     67            * See the License for the specific language governing permissions and
     68            * limitations under the License.
     69            *
     70            ******************************************************************************
     71            */ 
     72          
     73          /* Includes ------------------------------------------------------------------*/
     74          #include "stm8l15x_usart.h"
     75          
     76          /** @addtogroup STM8L15x_StdPeriph_Driver
     77            * @{
     78            */
     79          
     80          /** @defgroup USART 
     81            * @brief USART driver modules
     82            * @{
     83            */
     84          	
     85          /* Private typedef -----------------------------------------------------------*/
     86          /* Private define ------------------------------------------------------------*/
     87          /* Private macro -------------------------------------------------------------*/
     88          /* Private variables ---------------------------------------------------------*/
     89          /* Private function prototypes -----------------------------------------------*/
     90          /* Private functions ---------------------------------------------------------*/
     91          
     92          /** @defgroup USART_Private_Functions
     93            * @{
     94            */
     95          
     96          /** @defgroup USART_Group1 Initialization and Configuration functions
     97           *  @brief   Initialization and Configuration functions 
     98           *
     99          @verbatim   
    100           ===============================================================================
    101                            Initialization and Configuration functions
    102           ===============================================================================  
    103          
    104            This subsection provides a set of functions allowing to initialize the USART 
    105            in asynchronous and in synchronous modes.
    106             - For the asynchronous mode only these parameters can be configured: 
    107                  - Baud Rate
    108                  - Word Length 
    109                  - Stop Bit
    110                  - Parity: If the parity is enabled, then the MSB bit of the data written
    111                    in the data register is transmitted but is changed by the parity bit.
    112                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    113                    the possible USART frame formats are as listed in the following table:
    114             +-------------------------------------------------------------+     
    115             |   M bit |  PCE bit  |            USART frame                |
    116             |---------------------|---------------------------------------|             
    117             |    0    |    0      |    | SB | 8 bit data | STB |          |
    118             |---------|-----------|---------------------------------------|  
    119             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    120             |---------|-----------|---------------------------------------|  
    121             |    1    |    0      |    | SB | 9 bit data | STB |          |
    122             |---------|-----------|---------------------------------------|  
    123             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    124             +-------------------------------------------------------------+            
    125                  - Receiver/transmitter modes
    126          
    127            The USART_Init() function follows the USART  asynchronous configuration procedure
    128            (details for the procedure are available in reference manual (RM0031)).
    129          
    130            - For the synchronous mode in addition to the asynchronous mode parameters these 
    131              parameters should be also configured:
    132                  - USART Clock Enabled
    133                  - USART polarity
    134                  - USART phase
    135                  - USART LastBit
    136            
    137            These parameters can be configured using the USART_ClockInit() function.
    138          
    139          @endverbatim
    140            * @{
    141            */
    142          
    143          /**
    144            * @brief   Deinitializes the USART peripheral.
    145            * @param  USARTx: where x can be 1, 2 or 3 to select the specified USART peripheral.
    146            * @retval None
    147            */

   \                                 In section .near_func.text, align 1
    148          void USART_DeInit(USART_TypeDef* USARTx)
    149          {
   \                     USART_DeInit:
   \   000000 9093         LDW       Y, X
    150          
    151            /* Clear the Idle Line Detected bit in the status register by a read
    152                to the USART_SR register followed by a Read to the USART_DR register */
    153            (void) USARTx->SR;
   \   000002 90F6         LD        A, (Y)
   \   000004 B7 ..        LD        S:?b0, A
    154            (void) USARTx->DR;
   \   000006 93           LDW       X, Y
   \   000007 5C           INCW      X
   \   000008 F6           LD        A, (X)
    155          
    156            USARTx->BRR2 = USART_BRR2_RESET_VALUE;  /* Set USART_BRR2 to reset value 0x00 */
   \   000009 93           LDW       X, Y
   \   00000A 1C 0003      ADDW      X, #0x3
   \   00000D 7F           CLR       (X)
    157            USARTx->BRR1 = USART_BRR1_RESET_VALUE;  /* Set USART_BRR1 to reset value 0x00 */
   \   00000E 93           LDW       X, Y
   \   00000F 5C           INCW      X
   \   000010 5C           INCW      X
   \   000011 7F           CLR       (X)
    158          
    159            USARTx->CR1 = USART_CR1_RESET_VALUE;  /* Set USART_CR1 to reset value 0x00 */
   \   000012 93           LDW       X, Y
   \   000013 1C 0004      ADDW      X, #0x4
   \   000016 7F           CLR       (X)
    160            USARTx->CR2 = USART_CR2_RESET_VALUE;  /* Set USART_CR2 to reset value 0x00 */
   \   000017 93           LDW       X, Y
   \   000018 1C 0005      ADDW      X, #0x5
   \   00001B 7F           CLR       (X)
    161            USARTx->CR3 = USART_CR3_RESET_VALUE;  /* Set USART_CR3 to reset value 0x00 */
   \   00001C 93           LDW       X, Y
   \   00001D 1C 0006      ADDW      X, #0x6
   \   000020 7F           CLR       (X)
    162            USARTx->CR4 = USART_CR4_RESET_VALUE;  /* Set USART_CR4 to reset value 0x00 */
   \   000021 93           LDW       X, Y
   \   000022 1C 0007      ADDW      X, #0x7
   \   000025 7F           CLR       (X)
    163          }
   \   000026 81           RET
    164          
    165          /**
    166            * @brief  Initializes the USART according to the specified parameters.
    167            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
    168            *         correct I/O Port register according the product package and line
    169            *         configuration
    170            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    171            * @param  BaudRate: The baudrate.
    172            * @param  USART_WordLength: the word length
    173            *           This parameter can be one of the following values:
    174            *            @arg USART_WordLength_8b: 8 bits Data
    175            *            @arg USART_WordLength_9b: 9 bits Data  
    176            * @param  USART_StopBits: Stop Bit
    177            *           This parameter can be one of the following values:
    178            *            @arg USART_StopBits_1: One stop bit is transmitted at the end of frame
    179            *            @arg USART_StopBits_2: Two stop bits are transmitted at the end of frame
    180            *            @arg USART_StopBits_1_5: One and half stop bits
    181            * @param  USART_Parity: Parity
    182            *           This parameter can be one of the following values:
    183            *            @arg USART_Parity_No: No Parity
    184            *            @arg USART_Parity_Even: Even Parity
    185            *            @arg USART_Parity_Odd: Odd Parity    
    186            * @param  USART_Mode: Mode
    187            *           This parameter can be one of the following values:
    188            *            @arg USART_Mode_Rx: Receive Enable
    189            *            @arg USART_Mode_Tx: Transmit Enable  
    190            * @retval None
    191            */

   \                                 In section .near_func.text, align 1
    192          void USART_Init(USART_TypeDef* USARTx, 
    193                          uint32_t BaudRate, 
    194                          /*USART_WordLength_TypeDef*/ uint8_t USART_WordLength, 
    195                          /*USART_StopBits_TypeDef*/ uint8_t USART_StopBits,
    196                          /*USART_Parity_TypeDef*/ uint8_t USART_Parity, 
    197                          USART_Mode_TypeDef USART_Mode)
    198          {
   \                     USART_Init:
   \   000000 CD ....      CALL      L:?push_l2
   \   000003 CD ....      CALL      L:?push_l3
   \   000006 CD ....      CALL      L:?push_l0
   \   000009 88           PUSH      A
   \   00000A 3B ....      PUSH      S:?b4
   \   00000D 3B ....      PUSH      S:?b6
   \   000010 BF ..        LDW       S:?w4, X
   \   000012 45 .. ..     MOV       S:?b11, S:?b5
    199            uint32_t BaudRate_Mantissa = 0;
   \   000015 5F           CLRW      X
   \   000016 BF ..        LDW       S:?w7, X
   \   000018 BF ..        LDW       S:?w6, X
    200          
    201            /* Check the parameters */
    202            assert_param(IS_USART_BAUDRATE(BaudRate));
    203          
    204            assert_param(IS_USART_WORDLENGTH(USART_WordLength));
    205          
    206            assert_param(IS_USART_STOPBITS(USART_StopBits));
    207          
    208            assert_param(IS_USART_PARITY(USART_Parity));
    209          
    210            assert_param(IS_USART_MODE(USART_Mode));
    211          
    212            /* Clear the word length and Parity Control bits */
    213            USARTx->CR1 &= (uint8_t)(~(USART_CR1_PCEN | USART_CR1_PS | USART_CR1_M));
   \   00001A BE ..        LDW       X, S:?w4
   \   00001C 1C 0004      ADDW      X, #0x4
   \   00001F F6           LD        A, (X)
   \   000020 A4 E9        AND       A, #0xe9
   \   000022 BE ..        LDW       X, S:?w4
   \   000024 1C 0004      ADDW      X, #0x4
   \   000027 F7           LD        (X), A
    214            /* Set the word length bit according to USART_WordLength value */
    215            /* Set the Parity Control bit to USART_Parity value */
    216            USARTx->CR1 |= (uint8_t)((uint8_t)USART_WordLength | (uint8_t)USART_Parity);
   \   000028 7B 03        LD        A, (0x3,SP)
   \   00002A BA ..        OR        A, S:?b11
   \   00002C BE ..        LDW       X, S:?w4
   \   00002E 1C 0004      ADDW      X, #0x4
   \   000031 FA           OR        A, (X)
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 1C 0004      ADDW      X, #0x4
   \   000037 F7           LD        (X), A
    217          
    218            /* Clear the STOP bits */
    219            USARTx->CR3 &= (uint8_t)(~USART_CR3_STOP);
   \   000038 BE ..        LDW       X, S:?w4
   \   00003A 1C 0006      ADDW      X, #0x6
   \   00003D F6           LD        A, (X)
   \   00003E A4 CF        AND       A, #0xcf
   \   000040 BE ..        LDW       X, S:?w4
   \   000042 1C 0006      ADDW      X, #0x6
   \   000045 F7           LD        (X), A
    220            /* Set the STOP bits number according to USART_StopBits value */
    221            USARTx->CR3 |= (uint8_t)USART_StopBits;
   \   000046 BE ..        LDW       X, S:?w4
   \   000048 1C 0006      ADDW      X, #0x6
   \   00004B 7B 02        LD        A, (0x2,SP)
   \   00004D FA           OR        A, (X)
   \   00004E BE ..        LDW       X, S:?w4
   \   000050 1C 0006      ADDW      X, #0x6
   \   000053 F7           LD        (X), A
    222          
    223            /* Clear the LSB mantissa of USARTDIV */
    224            USARTx->BRR1 &= (uint8_t)(~USART_BRR1_DIVM);
   \   000054 BE ..        LDW       X, S:?w4
   \   000056 5C           INCW      X
   \   000057 5C           INCW      X
   \   000058 F6           LD        A, (X)
   \   000059 B7 ..        LD        S:?b10, A
   \   00005B BE ..        LDW       X, S:?w4
   \   00005D 5C           INCW      X
   \   00005E 5C           INCW      X
   \   00005F 7F           CLR       (X)
    225            /* Clear the MSB mantissa of USARTDIV */
    226            USARTx->BRR2 &= (uint8_t)(~USART_BRR2_DIVM);
   \   000060 BE ..        LDW       X, S:?w4
   \   000062 1C 0003      ADDW      X, #0x3
   \   000065 F6           LD        A, (X)
   \   000066 A4 0F        AND       A, #0xf
   \   000068 BE ..        LDW       X, S:?w4
   \   00006A 1C 0003      ADDW      X, #0x3
   \   00006D F7           LD        (X), A
    227            /* Clear the Fraction bits of USARTDIV */
    228            USARTx->BRR2 &= (uint8_t)(~USART_BRR2_DIVF);
   \   00006E BE ..        LDW       X, S:?w4
   \   000070 1C 0003      ADDW      X, #0x3
   \   000073 F6           LD        A, (X)
   \   000074 A4 F0        AND       A, #0xf0
   \   000076 BE ..        LDW       X, S:?w4
   \   000078 1C 0003      ADDW      X, #0x3
   \   00007B F7           LD        (X), A
    229          
    230            BaudRate_Mantissa  = (uint32_t)(CLK_GetClockFreq() / BaudRate );
   \   00007C CD ....      CALL      L:CLK_GetClockFreq
   \   00007F CD ....      CALL      L:?load32_l1_dbsp
   \   000082 04           DC8       0x4
   \   000083 CD ....      CALL      L:?udiv32_l0_l0_l1
   \   000086 CD ....      CALL      L:?mov_l3_l0
    231            /* Set the fraction of USARTDIV */
    232            USARTx->BRR2 = (uint8_t)((BaudRate_Mantissa >> (uint8_t)8) & (uint8_t)0xF0);
   \   000089 B6 ..        LD        A, S:?b14
   \   00008B A4 F0        AND       A, #0xf0
   \   00008D BE ..        LDW       X, S:?w4
   \   00008F 1C 0003      ADDW      X, #0x3
   \   000092 F7           LD        (X), A
    233            /* Set the MSB mantissa of USARTDIV */
    234            USARTx->BRR2 |= (uint8_t)(BaudRate_Mantissa & (uint8_t)0x0F);
   \   000093 B6 ..        LD        A, S:?b15
   \   000095 A4 0F        AND       A, #0xf
   \   000097 BE ..        LDW       X, S:?w4
   \   000099 1C 0003      ADDW      X, #0x3
   \   00009C FA           OR        A, (X)
   \   00009D BE ..        LDW       X, S:?w4
   \   00009F 1C 0003      ADDW      X, #0x3
   \   0000A2 F7           LD        (X), A
    235            /* Set the LSB mantissa of USARTDIV */
    236            USARTx->BRR1 = (uint8_t)(BaudRate_Mantissa >> (uint8_t)4);
   \   0000A3 BE ..        LDW       X, S:?w7
   \   0000A5 CD ....      CALL      L:?srl16_x_x_4
   \   0000A8 9F           LD        A, XL
   \   0000A9 BE ..        LDW       X, S:?w4
   \   0000AB 5C           INCW      X
   \   0000AC 5C           INCW      X
   \   0000AD F7           LD        (X), A
    237          
    238            /* Disable the Transmitter and Receiver */
    239            USARTx->CR2 &= (uint8_t)~(USART_CR2_TEN | USART_CR2_REN);
   \   0000AE BE ..        LDW       X, S:?w4
   \   0000B0 1C 0005      ADDW      X, #0x5
   \   0000B3 F6           LD        A, (X)
   \   0000B4 A4 F3        AND       A, #0xf3
   \   0000B6 BE ..        LDW       X, S:?w4
   \   0000B8 1C 0005      ADDW      X, #0x5
   \   0000BB F7           LD        (X), A
    240            /* Set TEN and REN bits according to USART_Mode value */
    241            USARTx->CR2 |= (uint8_t)USART_Mode;
   \   0000BC BE ..        LDW       X, S:?w4
   \   0000BE 1C 0005      ADDW      X, #0x5
   \   0000C1 7B 01        LD        A, (0x1,SP)
   \   0000C3 FA           OR        A, (X)
   \   0000C4 BE ..        LDW       X, S:?w4
   \   0000C6 1C 0005      ADDW      X, #0x5
   \   0000C9 F7           LD        (X), A
    242          }
   \   0000CA 5B 07        ADD       SP, #0x7
   \   0000CC CC ....      JP        L:?epilogue_l2_l3
    243          
    244          /**
    245            * @brief  Initializes the USART Clock according to the specified parameters.
    246            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    247            * @param  USART_Clock: Clock
    248            *           This parameter can be one of the following values:
    249            *            @arg USART_Clock_Disable: CK pin disabled
    250            *            @arg USART_Clock_Enable: CK pin enabled  
    251            * @param  USART_CPOL: Clock Polarity
    252            *           This parameter can be one of the following values:
    253            *            @arg USART_CPOL_Low: CK to 0 when idle
    254            *            @arg USART_CPOL_High: CK to 1 when idle
    255            * @param  USART_CPHA: Clock Phase
    256            *           This parameter can be one of the following values:
    257            *            @arg USART_CPHA_1Edge: The first clock transition is the first data capture edge
    258            *            @arg USART_CPHA_2Edge: The second clock transition is the first data capture edge
    259            * @param  USART_LastBit: Last Bit
    260            *           This parameter can be one of the following values:
    261            *            @arg USART_LastBit_Disable: The clock pulse of the last data bit is 
    262            *               not output to the SCLK pin
    263            *            @arg USART_LastBit_Enable: The clock pulse of the last data bit is 
    264            *               output to the SCLK pin
    265            * @retval None
    266            */

   \                                 In section .near_func.text, align 1
    267          void USART_ClockInit(USART_TypeDef* USARTx, USART_Clock_TypeDef USART_Clock,
    268                               USART_CPOL_TypeDef USART_CPOL, USART_CPHA_TypeDef USART_CPHA,
    269                               USART_LastBit_TypeDef USART_LastBit)
    270          {
   \                     USART_ClockInit:
   \   000000 B7 ..        LD        S:?b3, A
    271            /* Check the parameters */
    272            assert_param(IS_USART_CLOCK(USART_Clock));
    273            assert_param(IS_USART_CPOL(USART_CPOL));
    274            assert_param(IS_USART_CPHA(USART_CPHA));
    275            assert_param(IS_USART_LASTBIT(USART_LastBit));
    276          
    277            /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    278            USARTx->CR3 &= (uint8_t)~(USART_CR3_CPOL | USART_CR3_CPHA | USART_CR3_LBCL);
   \   000002 9093         LDW       Y, X
   \   000004 72A9 0006    ADDW      Y, #0x6
   \   000008 90F6         LD        A, (Y)
   \   00000A A4 F8        AND       A, #0xf8
   \   00000C 1C 0006      ADDW      X, #0x6
   \   00000F F7           LD        (X), A
   \   000010 1D 0006      SUBW      X, #0x6
    279            /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    280            USARTx->CR3 |= (uint8_t)((uint8_t)((uint8_t)(USART_CPOL | (uint8_t)USART_CPHA ) | USART_LastBit));
   \   000013 B6 ..        LD        A, S:?b1
   \   000015 BA ..        OR        A, S:?b0
   \   000017 BA ..        OR        A, S:?b2
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0006    ADDW      Y, #0x6
   \   00001F 90FA         OR        A, (Y)
   \   000021 1C 0006      ADDW      X, #0x6
   \   000024 F7           LD        (X), A
   \   000025 1D 0006      SUBW      X, #0x6
    281          
    282            if (USART_Clock != USART_Clock_Disable)
   \   000028 3D ..        TNZ       S:?b3
   \   00002A 27 13        JREQ      L:??USART_ClockInit_0
    283            {
    284              USARTx->CR3 |= (uint8_t)(USART_CR3_CLKEN); /* Set the Clock Enable bit */
   \   00002C 9093         LDW       Y, X
   \   00002E 72A9 0006    ADDW      Y, #0x6
   \   000032 90F6         LD        A, (Y)
   \   000034 AA 08        OR        A, #0x8
   \   000036 1C 0006      ADDW      X, #0x6
   \   000039 F7           LD        (X), A
   \   00003A 1D 0006      SUBW      X, #0x6
   \   00003D 20 11        JRA       L:??USART_ClockInit_1
    285            }
    286            else
    287            {
    288              USARTx->CR3 &= (uint8_t)(~USART_CR3_CLKEN); /* Clear the Clock Enable bit */
   \                     ??USART_ClockInit_0:
   \   00003F 9093         LDW       Y, X
   \   000041 72A9 0006    ADDW      Y, #0x6
   \   000045 90F6         LD        A, (Y)
   \   000047 A4 F7        AND       A, #0xf7
   \   000049 1C 0006      ADDW      X, #0x6
   \   00004C F7           LD        (X), A
   \   00004D 1D 0006      SUBW      X, #0x6
    289            }
    290          }
   \                     ??USART_ClockInit_1:
   \   000050 81           RET
    291          
    292          /**
    293            * @brief  Enable the USART peripheral.
    294            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    295            * @param  NewState: The new state of the USART Communication.
    296              *         This parameter can be: ENABLE or DISABLE.
    297            * @retval None
    298            */

   \                                 In section .near_func.text, align 1
    299          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    300          {
   \                     USART_Cmd:
   \   000000 B7 ..        LD        S:?b0, A
    301            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_Cmd_0
    302            {
    303              USARTx->CR1 &= (uint8_t)(~USART_CR1_USARTD); /**< USART Enable */
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0004    ADDW      Y, #0x4
   \   00000C 90F6         LD        A, (Y)
   \   00000E A4 DF        AND       A, #0xdf
   \   000010 1C 0004      ADDW      X, #0x4
   \   000013 F7           LD        (X), A
   \   000014 1D 0004      SUBW      X, #0x4
   \   000017 20 11        JRA       L:??USART_Cmd_1
    304            }
    305            else
    306            {
    307              USARTx->CR1 |= USART_CR1_USARTD;  /**< USART Disable (for low power consumption) */
   \                     ??USART_Cmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0004    ADDW      Y, #0x4
   \   00001F 90F6         LD        A, (Y)
   \   000021 AA 20        OR        A, #0x20
   \   000023 1C 0004      ADDW      X, #0x4
   \   000026 F7           LD        (X), A
   \   000027 1D 0004      SUBW      X, #0x4
    308            }
    309          }
   \                     ??USART_Cmd_1:
   \   00002A 81           RET
    310          
    311          /**
    312            * @brief  Sets the system clock prescaler.
    313            * @note   IrDA Low Power mode or smartcard mode should be enabled
    314            * @note   This function is related to SmartCard and IrDa mode.
    315            * @param  USARTx: Select the USARTx peripheral.
    316            * @param  USART_Prescaler: specifies the prescaler clock.
    317            * @note   In IrDA Low Power Mode the clock source is divided by the value given 
    318            *         in the register (8 bits)
    319            *         - 0000 0000 Reserved
    320            *         - 0000 0001 divides the clock source by 1
    321            *         - 0000 0010 divides the clock source by 2
    322            *         - ...
    323            * @note   In Smart Card Mode the clock source is divided by the value given in the register
    324            *         (5 significant bits) multiplied by 2
    325            *         - 0 0000 Reserved
    326            *         - 0 0001 divides the clock source by 2
    327            *         - 0 0010 divides the clock source by 4
    328            *         - 0 0011 divides the clock source by 6
    329            *         - ...
    330            * @retval None
    331            */

   \                                 In section .near_func.text, align 1
    332          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    333          {
    334            /* Load the USART prescaler value*/
    335            USARTx->PSCR = USART_Prescaler;
   \                     USART_SetPrescaler:
   \   000000 1C 000A      ADDW      X, #0xa
   \   000003 F7           LD        (X), A
   \   000004 1D 000A      SUBW      X, #0xa
    336          }
   \   000007 81           RET
    337          
    338          /**
    339            * @brief  Transmits break characters.
    340            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    341            * @retval None
    342            */

   \                                 In section .near_func.text, align 1
    343          void USART_SendBreak(USART_TypeDef* USARTx)
    344          {
    345            USARTx->CR2 |= USART_CR2_SBK;
   \                     USART_SendBreak:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0005    ADDW      Y, #0x5
   \   000006 90F6         LD        A, (Y)
   \   000008 AA 01        OR        A, #0x1
   \   00000A 1C 0005      ADDW      X, #0x5
   \   00000D F7           LD        (X), A
   \   00000E 1D 0005      SUBW      X, #0x5
    346          }
   \   000011 81           RET
    347          
    348          /**
    349            * @}
    350            */
    351          
    352          /** @defgroup USART_Group2 Data transfers functions
    353           *  @brief   Data transfers functions 
    354           *
    355          @verbatim   
    356           ===============================================================================
    357                                      Data transfers functions
    358           ===============================================================================  
    359          
    360            This subsection provides a set of functions allowing to manage the USART data 
    361            transfers.
    362            
    363            During an USART reception, data shifts in least significant bit first through 
    364            the RX pin. In this mode, the USART_DR register is similar to a buffer (RDR) 
    365            between the internal bus and the received shift register.
    366          
    367            When a transmission is taking place, a write instruction to the USART_DR register 
    368            stores the data in the TDR register which is copied in the shift register 
    369            at the end of the current transmission.
    370          
    371            The read access of the USART_DR register can be done using the USART_ReceiveData8()
    372            or USART_ReceiveData9() functions and returns the RDR buffered value. Whereas a write
    373          	access to the USART_DR can be done using USART_SendData8() or USART_SendData9() 
    374          	functions and stores the written data into TDR buffer.
    375          
    376          @endverbatim
    377            * @{
    378            */
    379          
    380          /**
    381            * @brief  Returns the most recent received data by the USART peripheral.
    382            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    383            * @retval The received data.
    384            */

   \                                 In section .near_func.text, align 1
    385          uint8_t USART_ReceiveData8(USART_TypeDef* USARTx)
    386          {
    387            return USARTx->DR;
   \                     USART_ReceiveData8:
   \   000000 5C           INCW      X
   \   000001 F6           LD        A, (X)
   \   000002 81           RET
    388          }
    389          
    390          /**
    391            * @brief  Returns the most recent received data by the USART peripheral.
    392            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    393            * @retval The received data.
    394            */

   \                                 In section .near_func.text, align 1
    395          uint16_t USART_ReceiveData9(USART_TypeDef* USARTx)
    396          {
   \                     USART_ReceiveData9:
   \   000000 9093         LDW       Y, X
    397            uint16_t temp = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
    398          
    399            temp = ((uint16_t)(((uint16_t)((uint16_t)USARTx->CR1 & (uint16_t)USART_CR1_R8)) << 1));
   \   000006 93           LDW       X, Y
   \   000007 1C 0004      ADDW      X, #0x4
   \   00000A F6           LD        A, (X)
   \   00000B 5F           CLRW      X
   \   00000C 97           LD        XL, A
   \   00000D 58           SLLW      X
   \   00000E 02           RLWA      X, A
   \   00000F A4 01        AND       A, #0x1
   \   000011 02           RLWA      X, A
   \   000012 A4 00        AND       A, #0x0
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
    400            return (uint16_t)( ((uint16_t)((uint16_t)USARTx->DR) | temp) & ((uint16_t)0x01FF));
   \   000017 905C         INCW      Y
   \   000019 90F6         LD        A, (Y)
   \   00001B 5F           CLRW      X
   \   00001C 97           LD        XL, A
   \   00001D 01           RRWA      X, A
   \   00001E BA ..        OR        A, S:?b1
   \   000020 01           RRWA      X, A
   \   000021 BA ..        OR        A, S:?b0
   \   000023 01           RRWA      X, A
   \   000024 02           RLWA      X, A
   \   000025 A4 01        AND       A, #0x1
   \   000027 02           RLWA      X, A
   \   000028 A4 FF        AND       A, #0xff
   \   00002A 02           RLWA      X, A
   \   00002B 81           RET
    401          }
    402          
    403          /**
    404            * @brief  Transmits 8 bit data through the USART peripheral.
    405            * @param  Data: The data to transmit.
    406            * @retval None
    407            */

   \                                 In section .near_func.text, align 1
    408          void USART_SendData8(USART_TypeDef* USARTx, uint8_t Data)
    409          {
   \                     USART_SendData8:
   \   000000 9093         LDW       Y, X
    410            /* Transmit Data */
    411            USARTx->DR = Data;
   \   000002 93           LDW       X, Y
   \   000003 5C           INCW      X
   \   000004 F7           LD        (X), A
    412          }
   \   000005 81           RET
    413          
    414          /**
    415            * @brief  Transmits 9 bit data through the USART peripheral.
    416            * @param  USARTx: Select the USARTx peripheral.
    417            * @param  Data: The data to transmit.
    418            *         This parameter should be lower than 0x1FF.
    419            * @retval None
    420            */

   \                                 In section .near_func.text, align 1
    421          void USART_SendData9(USART_TypeDef* USARTx, uint16_t Data)
    422          {
   \                     USART_SendData9:
   \   000000 BF ..        LDW       S:?w0, X
    423            assert_param(IS_USART_DATA_9BITS(Data));
    424          
    425            /* Clear the transmit data bit 8     */
    426            USARTx->CR1 &= ((uint8_t)~USART_CR1_T8);
   \   000002 BE ..        LDW       X, S:?w0
   \   000004 1C 0004      ADDW      X, #0x4
   \   000007 F6           LD        A, (X)
   \   000008 A4 BF        AND       A, #0xbf
   \   00000A BE ..        LDW       X, S:?w0
   \   00000C 1C 0004      ADDW      X, #0x4
   \   00000F F7           LD        (X), A
    427          
    428            /* Write the transmit data bit [8]   */
    429            USARTx->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & USART_CR1_T8);
   \   000010 93           LDW       X, Y
   \   000011 54           SRLW      X
   \   000012 54           SRLW      X
   \   000013 9F           LD        A, XL
   \   000014 A4 40        AND       A, #0x40
   \   000016 BE ..        LDW       X, S:?w0
   \   000018 1C 0004      ADDW      X, #0x4
   \   00001B FA           OR        A, (X)
   \   00001C BE ..        LDW       X, S:?w0
   \   00001E 1C 0004      ADDW      X, #0x4
   \   000021 F7           LD        (X), A
    430          
    431            /* Write the transmit data bit [0:7] */
    432            USARTx->DR   = (uint8_t)(Data);
   \   000022 BE ..        LDW       X, S:?w0
   \   000024 5C           INCW      X
   \   000025 909F         LD        A, YL
   \   000027 F7           LD        (X), A
    433          }
   \   000028 81           RET
    434          /**
    435            * @}
    436            */
    437          
    438          /** @defgroup USART_Group3 MultiProcessor Communication functions
    439           *  @brief   Multi-Processor Communication functions 
    440           *
    441          @verbatim   
    442           ===============================================================================
    443                              Multi-Processor Communication functions
    444           ===============================================================================  
    445          
    446            This subsection provides a set of functions allowing to manage the USART 
    447            multiprocessor communication.
    448            
    449            For instance one of the USARTs can be the master, its TX output is connected to 
    450            the RX input of the other USART. The others are slaves, their respective TX outputs 
    451            are logically ANDed together and connected to the RX input of the master.
    452          
    453            USART multiprocessor communication is possible through the following procedure:
    454               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    455                  or Mode receiver and hardware flow control values using the USART_Init()
    456                  function.
    457               2. Configures the USART address using the USART_SetAddress() function.
    458               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    459                  using USART_WakeUpConfig() function only for the slaves.
    460               4. Enable the USART using the USART_Cmd() function.
    461               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    462          
    463            The USART Slave exit from mute mode when receiving the wake up condition.
    464          
    465          @endverbatim
    466            * @{
    467            */
    468          	
    469          /**
    470            * @brief  Determines if the USART is in mute mode or not.
    471            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    472            * @param  NewState: The new state of the USART mode.
    473              *         This parameter can be: ENABLE or DISABLE.
    474            * @retval None
    475            */

   \                                 In section .near_func.text, align 1
    476          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    477          {
   \                     USART_ReceiverWakeUpCmd:
   \   000000 B7 ..        LD        S:?b0, A
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479          
    480            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_ReceiverWakeUpCmd_0
    481            {
    482              /* Enable the mute mode USART by setting the RWU bit in the CR2 register */
    483              USARTx->CR2 |= USART_CR2_RWU;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0005    ADDW      Y, #0x5
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 02        OR        A, #0x2
   \   000010 1C 0005      ADDW      X, #0x5
   \   000013 F7           LD        (X), A
   \   000014 1D 0005      SUBW      X, #0x5
   \   000017 20 11        JRA       L:??USART_ReceiverWakeUpCmd_1
    484            }
    485            else
    486            {
    487              /* Disable the mute mode USART by clearing the RWU bit in the CR1 register */
    488              USARTx->CR2 &= ((uint8_t)~USART_CR2_RWU);
   \                     ??USART_ReceiverWakeUpCmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0005    ADDW      Y, #0x5
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 FD        AND       A, #0xfd
   \   000023 1C 0005      ADDW      X, #0x5
   \   000026 F7           LD        (X), A
   \   000027 1D 0005      SUBW      X, #0x5
    489            }
    490          }
   \                     ??USART_ReceiverWakeUpCmd_1:
   \   00002A 81           RET
    491          
    492          /**
    493            * @brief  Sets the address of the USART node.
    494            * @param  USARTx: Select the USARTx peripheral.
    495            * @param  Address: Indicates the address of the USART node.
    496            *         This parameter should be lower than 16
    497            * @retval None
    498            */

   \                                 In section .near_func.text, align 1
    499          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    500          {
   \                     USART_SetAddress:
   \   000000 B7 ..        LD        S:?b0, A
    501            /* assert_param for USART_Address */
    502            assert_param(IS_USART_ADDRESS(USART_Address));
    503          
    504            /* Clear the USART address */
    505            USARTx->CR4 &= ((uint8_t)~USART_CR4_ADD);
   \   000002 9093         LDW       Y, X
   \   000004 72A9 0007    ADDW      Y, #0x7
   \   000008 90F6         LD        A, (Y)
   \   00000A A4 F0        AND       A, #0xf0
   \   00000C 1C 0007      ADDW      X, #0x7
   \   00000F F7           LD        (X), A
   \   000010 1D 0007      SUBW      X, #0x7
    506            /* Set the USART address node */
    507            USARTx->CR4 |= USART_Address;
   \   000013 9093         LDW       Y, X
   \   000015 72A9 0007    ADDW      Y, #0x7
   \   000019 90F6         LD        A, (Y)
   \   00001B BA ..        OR        A, S:?b0
   \   00001D 1C 0007      ADDW      X, #0x7
   \   000020 F7           LD        (X), A
   \   000021 1D 0007      SUBW      X, #0x7
    508          }
   \   000024 81           RET
    509          
    510          /**
    511            * @brief  Selects the USART WakeUp method.
    512            * @param  USART_WakeUp: Specifies the USART wakeup method.
    513            *           This parameter can be one of the following values:
    514            *            @arg USART_WakeUp_IdleLine: 0x01 Idle Line wake up
    515            *            @arg USART_WakeUp_AddressMark: 0x02 Address Mark wake up    
    516            * @retval None
    517            */

   \                                 In section .near_func.text, align 1
    518          void USART_WakeUpConfig(USART_TypeDef* USARTx, USART_WakeUp_TypeDef USART_WakeUp)
    519          {
   \                     USART_WakeUpConfig:
   \   000000 B7 ..        LD        S:?b0, A
    520            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    521          
    522            USARTx->CR1 &= ((uint8_t)~USART_CR1_WAKE);
   \   000002 9093         LDW       Y, X
   \   000004 72A9 0004    ADDW      Y, #0x4
   \   000008 90F6         LD        A, (Y)
   \   00000A A4 F7        AND       A, #0xf7
   \   00000C 1C 0004      ADDW      X, #0x4
   \   00000F F7           LD        (X), A
   \   000010 1D 0004      SUBW      X, #0x4
    523            USARTx->CR1 |= (uint8_t)USART_WakeUp;
   \   000013 9093         LDW       Y, X
   \   000015 72A9 0004    ADDW      Y, #0x4
   \   000019 90F6         LD        A, (Y)
   \   00001B BA ..        OR        A, S:?b0
   \   00001D 1C 0004      ADDW      X, #0x4
   \   000020 F7           LD        (X), A
   \   000021 1D 0004      SUBW      X, #0x4
    524          }
   \   000024 81           RET
    525          /**
    526            * @}
    527            */
    528          
    529          /** @defgroup USART_Group4 Halfduplex mode function
    530           *  @brief   Half-duplex mode function 
    531           *
    532          @verbatim   
    533           ===============================================================================
    534                                   Half-duplex mode function
    535           ===============================================================================  
    536          
    537            This subsection provides a function allowing to manage the USART 
    538            Half-duplex communication.
    539            
    540            The USART can be configured to follow a single-wire half-duplex protocol where 
    541            the TX and RX lines are internally connected.
    542          
    543            USART Half duplex communication is possible through the following procedure:
    544               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    545                  or Mode receiver and hardware flow control values using the USART_Init()
    546                  function.
    547               2. Configures the USART address using the USART_SetAddress() function.
    548               3. Enable the USART using the USART_Cmd() function.
    549               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    550          
    551          Note:
    552          ----
    553            1. The RX pin is no longer used
    554            2. In Half-duplex mode the following bits must be kept cleared:
    555                 - CLKEN bits in the USART_CR3 register.
    556                 - SCEN and IREN bits in the USART_CR5 register.
    557          
    558          @endverbatim
    559            * @{
    560            */
    561          
    562          /**
    563            * @brief  Enables or disables the USART’s Half Duplex communication.
    564            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    565            * @param  NewState new state of the USART Communication.
    566              *         This parameter can be: ENABLE or DISABLE.
    567            * @retval None
    568            */

   \                                 In section .near_func.text, align 1
    569          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    570          {
   \                     USART_HalfDuplexCmd:
   \   000000 B7 ..        LD        S:?b0, A
    571            assert_param(IS_FUNCTIONAL_STATE(NewState));
    572          
    573            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_HalfDuplexCmd_0
    574            {
    575              USARTx->CR5 |= USART_CR5_HDSEL;  /**< USART Half Duplex Enable  */
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 08        OR        A, #0x8
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 11        JRA       L:??USART_HalfDuplexCmd_1
    576            }
    577            else
    578            {
    579              USARTx->CR5 &= (uint8_t)~USART_CR5_HDSEL; /**< USART Half Duplex Disable */
   \                     ??USART_HalfDuplexCmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 F7        AND       A, #0xf7
   \   000023 1C 0008      ADDW      X, #0x8
   \   000026 F7           LD        (X), A
   \   000027 1D 0008      SUBW      X, #0x8
    580            }
    581          }
   \                     ??USART_HalfDuplexCmd_1:
   \   00002A 81           RET
    582          
    583          /**
    584            * @}
    585            */
    586          
    587          /** @defgroup USART_Group5 Smartcard mode functions
    588           *  @brief   Smartcard mode functions 
    589           *
    590          @verbatim   
    591           ===============================================================================
    592                                         Smartcard mode functions
    593           ===============================================================================  
    594          
    595            This subsection provides a set of functions allowing to manage the USART 
    596            Smartcard communication.
    597            
    598            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    599            defined in the ISO 7816-3 standard.
    600          
    601            The USART can provide a clock to the smartcard through the SCLK output.
    602            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    603            from the internal peripheral input clock through a 5-bit prescaler.
    604          
    605            Smartcard communication is possible through the following procedure:
    606               1. Configures the Smartcard Prsecaler using the USART_SetPrescaler() function.
    607               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    608               3. Program the USART clock using the USART_ClockInit() function as following:
    609                  - USART Clock enabled
    610                  - USART CPOL Low
    611                  - USART CPHA on first edge
    612                  - USART Last Bit Clock Enabled
    613               4. Program the Smartcard interface using the USART_Init() function as following:
    614                  - Word Length = 9 Bits
    615                  - 1.5 Stop Bit
    616                  - Even parity
    617                  - BaudRate = 12096 baud
    618                  - Hardware flow control disabled (RTS and CTS signals)
    619                  - Tx and Rx enabled
    620               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    621                  function
    622               6. Enable the USART using the USART_Cmd() function.
    623               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    624               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    625          
    626            Please refer to the ISO 7816-3 specification for more details.
    627          
    628          Note: 
    629          -----
    630            1.  It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    631                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    632                between the two configurations.
    633            2. In smartcard mode, the following bits must be kept cleared:
    634               - HDSEL and IREN bits in the USART_CR5 register.
    635          
    636          @endverbatim
    637            * @{
    638            */
    639          	
    640          /**
    641            * @brief  Enables or disables the USART Smart Card mode.
    642            * @param  USARTx: Select the USARTx peripheral.
    643            * @param  NewState: new state of the Smart Card mode.
    644              *         This parameter can be: ENABLE or DISABLE.
    645            * @retval None
    646            */

   \                                 In section .near_func.text, align 1
    647          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    648          {
   \                     USART_SmartCardCmd:
   \   000000 B7 ..        LD        S:?b0, A
    649            assert_param(IS_FUNCTIONAL_STATE(NewState));
    650          
    651            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_SmartCardCmd_0
    652            {
    653              /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    654              USARTx->CR5 |= USART_CR5_SCEN;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 20        OR        A, #0x20
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 11        JRA       L:??USART_SmartCardCmd_1
    655            }
    656            else
    657            {
    658              /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    659              USARTx->CR5 &= ((uint8_t)(~USART_CR5_SCEN));
   \                     ??USART_SmartCardCmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 DF        AND       A, #0xdf
   \   000023 1C 0008      ADDW      X, #0x8
   \   000026 F7           LD        (X), A
   \   000027 1D 0008      SUBW      X, #0x8
    660            }
    661          }
   \                     ??USART_SmartCardCmd_1:
   \   00002A 81           RET
    662          
    663          /**
    664            * @brief  Enables or disables NACK transmission.
    665            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    666            * @param  NewState: new state of the Smart Card mode.
    667              *         This parameter can be: ENABLE or DISABLE.
    668            * @retval None
    669            */

   \                                 In section .near_func.text, align 1
    670          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    671          {
   \                     USART_SmartCardNACKCmd:
   \   000000 B7 ..        LD        S:?b0, A
    672            assert_param(IS_FUNCTIONAL_STATE(NewState));
    673          
    674            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_SmartCardNACKCmd_0
    675            {
    676              /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    677              USARTx->CR5 |= USART_CR5_NACK;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 10        OR        A, #0x10
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 11        JRA       L:??USART_SmartCardNACKCmd_1
    678            }
    679            else
    680            {
    681              /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    682              USARTx->CR5 &= ((uint8_t)~(USART_CR5_NACK));
   \                     ??USART_SmartCardNACKCmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 EF        AND       A, #0xef
   \   000023 1C 0008      ADDW      X, #0x8
   \   000026 F7           LD        (X), A
   \   000027 1D 0008      SUBW      X, #0x8
    683            }
    684          }
   \                     ??USART_SmartCardNACKCmd_1:
   \   00002A 81           RET
    685          
    686          /**
    687            * @brief  Sets the specified USART guard time.
    688            * @note   SmartCard Mode should be Enabled
    689            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    690            * @param  USART_GuardTime: specifies the guard time.
    691            * @retval None
    692            */

   \                                 In section .near_func.text, align 1
    693          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    694          {
    695            /* Set the USART guard time */
    696            USARTx->GTR = USART_GuardTime;
   \                     USART_SetGuardTime:
   \   000000 1C 0009      ADDW      X, #0x9
   \   000003 F7           LD        (X), A
   \   000004 1D 0009      SUBW      X, #0x9
    697          }
   \   000007 81           RET
    698          
    699          /**
    700            * @}
    701            */
    702          
    703          /** @defgroup USART_Group6 IrDA mode functions
    704           *  @brief   IrDA mode functions 
    705           *
    706          @verbatim   
    707           ===============================================================================
    708                                          IrDA mode functions
    709           ===============================================================================  
    710          
    711            This subsection provides a set of functions allowing to manage the USART 
    712            IrDA communication.
    713            
    714            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    715            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    716            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    717            While receiving data, transmission should be avoided as the data to be transmitted
    718            could be corrupted.
    719          
    720            IrDA communication is possible through the following procedure:
    721               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    722                  modes and hardware flow control values using the USART_Init() function.
    723               2. Enable the USART using the USART_Cmd() function.
    724               3. Configures the IrDA pulse width by configuring the prescaler using  
    725                  the USART_SetPrescaler() function.
    726               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    727                  using the USART_IrDAConfig() function.
    728               5. Enable the IrDA using the USART_IrDACmd() function.
    729          
    730          Note: 
    731          -----
    732            1. A pulse of width less than two and greater than one PSC period(s) may or may
    733               not be rejected.
    734            2. The receiver set up time should be managed by software. The IrDA physical layer
    735               specification specifies a minimum of 10 ms delay between transmission and 
    736               reception (IrDA is a half duplex protocol).
    737            3. In IrDA mode, the following bits must be kept cleared:
    738              - STOP and CLKEN bits in the USART_CR3 register.
    739              - SCEN and HDSEL bits in the USART_CR5 register.
    740          
    741          @endverbatim
    742            * @{
    743            */
    744          	
    745          /**
    746            * @brief  Configures the USART’s IrDA interface.
    747            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    748            * @param  USART_IrDAMode specifies the IrDA mode.
    749            *           This parameter can be one of the following values:
    750            *            @arg USART_IrDAMode_Normal: IrDA Normal Mode
    751            *            @arg USART_IrDAMode_LowPower: IrDA Low Power Mode 
    752            * @retval None
    753            */

   \                                 In section .near_func.text, align 1
    754          void USART_IrDAConfig(USART_TypeDef* USARTx, USART_IrDAMode_TypeDef USART_IrDAMode)
    755          {
   \                     USART_IrDAConfig:
   \   000000 B7 ..        LD        S:?b0, A
    756            assert_param(IS_USART_IRDAMODE(USART_IrDAMode));
    757          
    758            if (USART_IrDAMode != USART_IrDAMode_Normal)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_IrDAConfig_0
    759            {
    760              USARTx->CR5 |= USART_CR5_IRLP;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 04        OR        A, #0x4
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 11        JRA       L:??USART_IrDAConfig_1
    761            }
    762            else
    763            {
    764              USARTx->CR5 &= ((uint8_t)~USART_CR5_IRLP);
   \                     ??USART_IrDAConfig_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 FB        AND       A, #0xfb
   \   000023 1C 0008      ADDW      X, #0x8
   \   000026 F7           LD        (X), A
   \   000027 1D 0008      SUBW      X, #0x8
    765            }
    766          }
   \                     ??USART_IrDAConfig_1:
   \   00002A 81           RET
    767          
    768          /**
    769            * @brief  Enables or disables the USART’s IrDA interface.
    770            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    771            * @param  NewState new state of the IrDA mode.
    772              *         This parameter can be: ENABLE or DISABLE.
    773            * @retval None
    774            */

   \                                 In section .near_func.text, align 1
    775          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
    776          {
   \                     USART_IrDACmd:
   \   000000 B7 ..        LD        S:?b0, A
    777          
    778            /* Check parameters */
    779            assert_param(IS_FUNCTIONAL_STATE(NewState));
    780          
    781            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_IrDACmd_0
    782            {
    783              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    784              USARTx->CR5 |= USART_CR5_IREN;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E AA 02        OR        A, #0x2
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 11        JRA       L:??USART_IrDACmd_1
    785            }
    786            else
    787            {
    788              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    789              USARTx->CR5 &= ((uint8_t)~USART_CR5_IREN);
   \                     ??USART_IrDACmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F 90F6         LD        A, (Y)
   \   000021 A4 FD        AND       A, #0xfd
   \   000023 1C 0008      ADDW      X, #0x8
   \   000026 F7           LD        (X), A
   \   000027 1D 0008      SUBW      X, #0x8
    790            }
    791          }
   \                     ??USART_IrDACmd_1:
   \   00002A 81           RET
    792          
    793          /**
    794            * @}
    795            */
    796          
    797          /** @defgroup USART_Group7 DMA transfers management functions
    798           *  @brief   DMA transfers management functions
    799           *
    800          @verbatim   
    801           ===============================================================================
    802                                DMA transfers management functions
    803           ===============================================================================  
    804          
    805          @endverbatim
    806            * @{
    807            */
    808          
    809          
    810          /**
    811            * @brief  Enables or disables the USART DMA interface.
    812            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    813            * @param  USART_DMAReq Specifies the USART DMA transfer request to be enabled or disabled.
    814            *           This parameter can be one of the following values:
    815            *            @arg USART_DMAReq_TX: Receive DMA request Enable
    816            *            @arg USART_DMAReq_RX: Transmit DMA request Enable 
    817            * @param  NewState Indicates the new state of the USART DMA request.
    818              *         This parameter can be: ENABLE or DISABLE.
    819            * @retval None
    820            */

   \                                 In section .near_func.text, align 1
    821          void USART_DMACmd(USART_TypeDef* USARTx, USART_DMAReq_TypeDef USART_DMAReq,
    822                            FunctionalState NewState)
    823          {
   \                     USART_DMACmd:
   \   000000 B7 ..        LD        S:?b1, A
    824            /* Check the parameters */
    825            assert_param(IS_USART_DMAREQ(USART_DMAReq));
    826            assert_param(IS_FUNCTIONAL_STATE(NewState));
    827          
    828            if (NewState != DISABLE)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 13        JREQ      L:??USART_DMACmd_0
    829            {
    830              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
    831                 DMAR bits in the USART CR5 register */
    832              USARTx->CR5 |= (uint8_t) USART_DMAReq;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0008    ADDW      Y, #0x8
   \   00000C 90F6         LD        A, (Y)
   \   00000E BA ..        OR        A, S:?b1
   \   000010 1C 0008      ADDW      X, #0x8
   \   000013 F7           LD        (X), A
   \   000014 1D 0008      SUBW      X, #0x8
   \   000017 20 12        JRA       L:??USART_DMACmd_1
    833            }
    834            else
    835            {
    836              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
    837                 DMAR bits in the USART CR5 register */
    838              USARTx->CR5 &= (uint8_t)~USART_DMAReq;
   \                     ??USART_DMACmd_0:
   \   000019 9093         LDW       Y, X
   \   00001B 72A9 0008    ADDW      Y, #0x8
   \   00001F B6 ..        LD        A, S:?b1
   \   000021 43           CPL       A
   \   000022 90F4         AND       A, (Y)
   \   000024 1C 0008      ADDW      X, #0x8
   \   000027 F7           LD        (X), A
   \   000028 1D 0008      SUBW      X, #0x8
    839            }
    840          }
   \                     ??USART_DMACmd_1:
   \   00002B 81           RET
    841          
    842          /**
    843            * @}
    844            */
    845            
    846          /** @defgroup USART_Group8 Interrupts and flags management functions
    847           *  @brief   Interrupts and flags management functions 
    848           *
    849          @verbatim   
    850           ===============================================================================
    851                             Interrupts and flags management functions
    852           ===============================================================================  
    853          
    854            This subsection provides a set of functions allowing to configure the USART 
    855            Interrupts sources, DMA channels requests and check or clear the flags or 
    856            pending bits status.
    857            The user should identify which mode will be used in his application to manage 
    858            the communication: Polling mode, Interrupt mode or DMA mode. 
    859              
    860            Polling Mode
    861            =============
    862            In Polling Mode, the USART communication can be managed by 9 flags:
    863               1. USART_FLAG_TXE: to indicate the status of the transmit buffer register
    864               2. USART_FLAG_RXNE: to indicate the status of the receive buffer register
    865               3. USART_FLAG_TC: to indicate the status of the transmit operation
    866               4. USART_FLAG_IDLE: to indicate the status of the Idle Line             
    867               5. USART_FLAG_SBK: to indicate the status of the Send Break characters
    868               6. USART_FLAG_NE: to indicate if a noise error occur
    869               7. USART_FLAG_FE: to indicate if a frame error occur
    870               8. USART_FLAG_PE: to indicate if a parity error occur
    871               9. USART_FLAG_ORE: to indicate if an Overrun error occur
    872          
    873            In this Mode it is advised to use the following functions:
    874                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG);
    875                - void USART_ClearFlag(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG);
    876          
    877            Interrupt Mode
    878            ===============
    879            In Interrupt Mode, the USART communication can be managed by 7 interrupt sources
    880            and 6 pending bits: 
    881          
    882            Pending Bits:
    883            ------------- 
    884               1. USART_IT_TXE: to indicate the status of the transmit buffer register
    885               2. USART_IT_RXNE: to indicate the status of the receive buffer register
    886               3. USART_IT_TC: to indicate the status of the transmit operation
    887               4. USART_IT_IDLE: to indicate the status of the Idle Line             
    888               5. USART_IT_PE: to indicate if a parity error occur
    889               6. USART_IT_OR: to indicate if an Noise flag, overrun error and framing error in
    890          											multibuffer communication error occur
    891          
    892            Interrupt Source:
    893            -----------------
    894               1. USART_IT_TXE: specifies the interrupt source for the Tx buffer empty 
    895                                 interrupt. 
    896               2. USART_IT_RXNE: specifies the interrupt source for the Rx buffer not 
    897                                  empty interrupt.
    898               3. USART_IT_TC: specifies the interrupt source for the Transmit complete 
    899          											interrupt. 
    900               4. USART_IT_IDLE: specifies the interrupt source for the Idle Line interrupt.
    901               5. USART_IT_PE: specifies the interrupt source for the parity error interrupt. 
    902               6. USART_IT_ERR:  specifies the interrupt source for the errors interrupt.
    903          		 7. USART_IT_OR: specifies the interrupt source for the overrun error interrupt.
    904          
    905              Note: Some parameters are coded in order to use them as interrupt source or 
    906              ----  as pending bits.
    907          
    908            In this Mode it is advised to use the following functions:
    909               - void USART_ITConfig(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT, FunctionalState
    910                                		 NewState);
    911               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT);
    912               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT);
    913          
    914            DMA Mode
    915            ========
    916            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
    917               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
    918               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
    919          
    920            In this Mode it is advised to use the following function:
    921               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
    922          
    923          @endverbatim
    924            * @{
    925            */
    926          
    927          /**
    928            * @brief  Enables or disables the specified USART interrupts.
    929            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
    930            * @param  USART_IT specifies the USART interrupt sources to be enabled or disabled.
    931            *         This parameter can be one of the following values:
    932            *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
    933            *            @arg USART_IT_TC: Transmission complete interrupt
    934            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
    935            *            @arg USART_IT_OR: Overrun error interrupt
    936            *            @arg USART_IT_IDLE: Idle line detection interrupt
    937            *            @arg USART_IT_ERR: Error interrupt
    938            * @param  NewState new state of the specified USART interrupts.
    939              *         This parameter can be: ENABLE or DISABLE.
    940            * @retval None
    941            */

   \                                 In section .near_func.text, align 1
    942          void USART_ITConfig(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT, FunctionalState NewState)
    943          {
   \                     USART_ITConfig:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 B7 ..        LD        S:?b2, A
    944            uint8_t usartreg, itpos = 0x00;
   \   000004 3F ..        CLR       S:?b4
    945            assert_param(IS_USART_CONFIG_IT(USART_IT));
    946            assert_param(IS_FUNCTIONAL_STATE(NewState));
    947          
    948            /* Get the USART register index */
    949            usartreg = (uint8_t)((uint16_t)USART_IT >> 0x08);
   \   000006 909E         LD        A, YH
   \   000008 B7 ..        LD        S:?b3, A
    950            /* Get the USART IT index */
    951            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
   \   00000A 909F         LD        A, YL
   \   00000C A4 0F        AND       A, #0xf
   \   00000E 5F           CLRW      X
   \   00000F 5C           INCW      X
   \   000010 CD ....      CALL      L:?sll16_x_x_a
   \   000013 9F           LD        A, XL
   \   000014 B7 ..        LD        S:?b4, A
    952          
    953            if (NewState != DISABLE)
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 3C        JREQ      L:??USART_ITConfig_0
    954            {
    955              /**< Enable the Interrupt bits according to USART_IT mask */
    956              if (usartreg == 0x01)
   \   00001A B6 ..        LD        A, S:?b3
   \   00001C A1 01        CP        A, #0x1
   \   00001E 26 10        JRNE      L:??USART_ITConfig_1
    957              {
    958                USARTx->CR1 |= itpos;
   \   000020 BE ..        LDW       X, S:?w0
   \   000022 1C 0004      ADDW      X, #0x4
   \   000025 F6           LD        A, (X)
   \   000026 BA ..        OR        A, S:?b4
   \   000028 BE ..        LDW       X, S:?w0
   \   00002A 1C 0004      ADDW      X, #0x4
   \   00002D F7           LD        (X), A
   \   00002E 20 63        JRA       L:??USART_ITConfig_2
    959              }
    960              else if (usartreg == 0x05)
   \                     ??USART_ITConfig_1:
   \   000030 B6 ..        LD        A, S:?b3
   \   000032 A1 05        CP        A, #0x5
   \   000034 26 10        JRNE      L:??USART_ITConfig_3
    961              {
    962                USARTx->CR5 |= itpos;
   \   000036 BE ..        LDW       X, S:?w0
   \   000038 1C 0008      ADDW      X, #0x8
   \   00003B F6           LD        A, (X)
   \   00003C BA ..        OR        A, S:?b4
   \   00003E BE ..        LDW       X, S:?w0
   \   000040 1C 0008      ADDW      X, #0x8
   \   000043 F7           LD        (X), A
   \   000044 20 4D        JRA       L:??USART_ITConfig_2
    963              }
    964              /*uartreg =0x02*/
    965              else
    966              {
    967                USARTx->CR2 |= itpos;
   \                     ??USART_ITConfig_3:
   \   000046 BE ..        LDW       X, S:?w0
   \   000048 1C 0005      ADDW      X, #0x5
   \   00004B F6           LD        A, (X)
   \   00004C BA ..        OR        A, S:?b4
   \   00004E BE ..        LDW       X, S:?w0
   \   000050 1C 0005      ADDW      X, #0x5
   \   000053 F7           LD        (X), A
   \   000054 20 3D        JRA       L:??USART_ITConfig_2
    968              }
    969            }
    970            else
    971            {
    972              /**< Disable the interrupt bits according to USART_IT mask */
    973              if (usartreg == 0x01)
   \                     ??USART_ITConfig_0:
   \   000056 B6 ..        LD        A, S:?b3
   \   000058 A1 01        CP        A, #0x1
   \   00005A 26 11        JRNE      L:??USART_ITConfig_4
    974              {
    975                USARTx->CR1 &= (uint8_t)(~itpos);
   \   00005C BE ..        LDW       X, S:?w0
   \   00005E 1C 0004      ADDW      X, #0x4
   \   000061 B6 ..        LD        A, S:?b4
   \   000063 43           CPL       A
   \   000064 F4           AND       A, (X)
   \   000065 BE ..        LDW       X, S:?w0
   \   000067 1C 0004      ADDW      X, #0x4
   \   00006A F7           LD        (X), A
   \   00006B 20 26        JRA       L:??USART_ITConfig_2
    976              }
    977              else if (usartreg == 0x05)
   \                     ??USART_ITConfig_4:
   \   00006D B6 ..        LD        A, S:?b3
   \   00006F A1 05        CP        A, #0x5
   \   000071 26 11        JRNE      L:??USART_ITConfig_5
    978              {
    979                USARTx->CR5 &= (uint8_t)(~itpos);
   \   000073 BE ..        LDW       X, S:?w0
   \   000075 1C 0008      ADDW      X, #0x8
   \   000078 B6 ..        LD        A, S:?b4
   \   00007A 43           CPL       A
   \   00007B F4           AND       A, (X)
   \   00007C BE ..        LDW       X, S:?w0
   \   00007E 1C 0008      ADDW      X, #0x8
   \   000081 F7           LD        (X), A
   \   000082 20 0F        JRA       L:??USART_ITConfig_2
    980              }
    981              /*uartreg =0x02*/
    982              else
    983              {
    984                USARTx->CR2 &= (uint8_t)(~itpos);
   \                     ??USART_ITConfig_5:
   \   000084 BE ..        LDW       X, S:?w0
   \   000086 1C 0005      ADDW      X, #0x5
   \   000089 B6 ..        LD        A, S:?b4
   \   00008B 43           CPL       A
   \   00008C F4           AND       A, (X)
   \   00008D BE ..        LDW       X, S:?w0
   \   00008F 1C 0005      ADDW      X, #0x5
   \   000092 F7           LD        (X), A
    985              }
    986            }
    987          }
   \                     ??USART_ITConfig_2:
   \   000093 81           RET
    988          
    989          /**
    990            * @brief  Checks whether the specified USART flag is set or not.
    991            * @param  USARTx: Select the USARTx peripheral.
    992            * @param  USART_FLAG specifies the flag to check.
    993            *         This parameter can be one of the following values:
    994            *            @arg USART_FLAG_TXE: Transmit Data Register empty
    995            *            @arg USART_FLAG_TC: Transmission Complete 
    996            *            @arg USART_FLAG_RXNE: Read Data Register Not Empty
    997            *            @arg USART_FLAG_IDLE: Idle line detected
    998            *            @arg USART_FLAG_OR: OverRun error
    999            *            @arg USART_FLAG_NF: Noise error
   1000            *            @arg USART_FLAG_FE: Framing Error
   1001            *            @arg USART_FLAG_PE: Parity Error
   1002            *            @arg USART_FLAG_SBK: Send Break characters               
   1003            * @retval FlagStatus (SET or RESET)
   1004            */

   \                                 In section .near_func.text, align 1
   1005          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
   1006          {
   \                     USART_GetFlagStatus:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 93           LDW       X, Y
   1007            FlagStatus status = RESET;
   \   000003 3F ..        CLR       S:?b2
   1008          
   1009            /* Check parameters */
   1010            assert_param(IS_USART_FLAG(USART_FLAG));
   1011          
   1012            if (USART_FLAG == USART_FLAG_SBK)
   \   000005 A3 0101      CPW       X, #0x101
   \   000008 26 18        JRNE      L:??USART_GetFlagStatus_0
   1013            {
   1014              if ((USARTx->CR2 & (uint8_t)USART_FLAG) != (uint8_t)0x00)
   \   00000A 90BE ..      LDW       Y, S:?w0
   \   00000D 72A9 0005    ADDW      Y, #0x5
   \   000011 9F           LD        A, XL
   \   000012 90F4         AND       A, (Y)
   \   000014 A1 00        CP        A, #0x0
   \   000016 27 06        JREQ      L:??USART_GetFlagStatus_1
   1015              {
   1016                /* USART_FLAG is set*/
   1017                status = SET;
   \   000018 A6 01        LD        A, #0x1
   \   00001A B7 ..        LD        S:?b2, A
   \   00001C 20 14        JRA       L:??USART_GetFlagStatus_2
   1018              }
   1019              else
   1020              {
   1021                /* USART_FLAG is reset*/
   1022                status = RESET;
   \                     ??USART_GetFlagStatus_1:
   \   00001E 3F ..        CLR       S:?b2
   \   000020 20 10        JRA       L:??USART_GetFlagStatus_2
   1023              }
   1024            }
   1025            else
   1026            {
   1027              if ((USARTx->SR & (uint8_t)USART_FLAG) != (uint8_t)0x00)
   \                     ??USART_GetFlagStatus_0:
   \   000022 9F           LD        A, XL
   \   000023 92C4 ..      AND       A, [S:?w0.w]
   \   000026 A1 00        CP        A, #0x0
   \   000028 27 06        JREQ      L:??USART_GetFlagStatus_3
   1028              {
   1029                /* USART_FLAG is set*/
   1030                status = SET;
   \   00002A A6 01        LD        A, #0x1
   \   00002C B7 ..        LD        S:?b2, A
   \   00002E 20 02        JRA       L:??USART_GetFlagStatus_2
   1031              }
   1032              else
   1033              {
   1034                /* USART_FLAG is reset*/
   1035                status = RESET;
   \                     ??USART_GetFlagStatus_3:
   \   000030 3F ..        CLR       S:?b2
   1036              }
   1037            }
   1038            /* Return the USART_FLAG status*/
   1039            return status;
   \                     ??USART_GetFlagStatus_2:
   \   000032 B6 ..        LD        A, S:?b2
   \   000034 81           RET
   1040          }
   1041          
   1042          /**
   1043            * @brief  Clears the USARTx's pending flags.
   1044            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
   1045            * @param  USART_FLAG: specifies the flag to clear.
   1046            *         This parameter can be any combination of the following values:
   1047            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1048            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1049            * @note   PE (Parity error), FE (Framing error), NE (Noise error), OR (OverRun error)
   1050            *         and IDLE (Idle line detected) flags are cleared by software sequence: a read
   1051            *         operation to USART_SR register (USART_GetFlagStatus())followed by a read
   1052            *         operation to USART_DR register(USART_ReceiveData8() or USART_ReceiveData9()).
   1053            * @note   RXNE flag can be also cleared by a read to the USART_DR register
   1054            *         (USART_ReceiveData8()or USART_ReceiveData9()).
   1055            * @note   TC flag can be also cleared by software sequence: a read operation to USART_SR
   1056            *         register (USART_GetFlagStatus()) followed by a write operation to USART_DR
   1057            *         register (USART_SendData8() or USART_SendData9()).
   1058            * @note    TXE flag is cleared only by a write to the USART_DR register
   1059            *         (USART_SendData8() or USART_SendData9()).
   1060            * @note   SBK flag is cleared during the stop bit of break.
   1061            * @retval None
   1062            */

   \                                 In section .near_func.text, align 1
   1063          void USART_ClearFlag(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
   1064          {
   1065            /* Check the parameters */
   1066            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   1067            /*< Clear RXNE or TC flags */
   1068            USARTx->SR = (uint8_t)((uint16_t)~((uint16_t)USART_FLAG));
   \                     USART_ClearFlag:
   \   000000 909F         LD        A, YL
   \   000002 43           CPL       A
   \   000003 F7           LD        (X), A
   1069          }
   \   000004 81           RET
   1070          
   1071          /**
   1072            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1073            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
   1074            * @param  USART_IT: Specifies the USART interrupt pending bit to check.
   1075            *         This parameter can be one of the following values:
   1076            *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
   1077            *            @arg USART_IT_TC: Transmission complete interrupt
   1078            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1079            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1080            *            @arg USART_IT_OR: OverRun Error interrupt
   1081            *            @arg USART_IT_PE: Parity Error interrupt
   1082            *            @arg USART_IT_FE: Frame Error interrupt
   1083            *            @arg USART_IT_NF: Noise Flag Error interrupt
   1084            * @retval ITStatus The new state of USART_IT (SET or RESET).
   1085            */

   \                                 In section .near_func.text, align 1
   1086          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT)
   1087          {
   \                     USART_GetITStatus:
   \   000000 BF ..        LDW       S:?w0, X
   1088            ITStatus pendingbitstatus = RESET;
   \   000002 3F ..        CLR       S:?b2
   1089            uint8_t temp = 0;
   \   000004 3F ..        CLR       S:?b4
   1090            uint8_t itpos = 0;
   \   000006 3F ..        CLR       S:?b7
   1091            uint8_t itmask1 = 0;
   \   000008 3F ..        CLR       S:?b5
   1092            uint8_t itmask2 = 0;
   \   00000A 3F ..        CLR       S:?b6
   1093            uint8_t enablestatus = 0;
   \   00000C 3F ..        CLR       S:?b3
   1094          
   1095            /* Check parameters */
   1096            assert_param(IS_USART_GET_IT(USART_IT));
   1097          
   1098            /* Get the USART IT index */
   1099            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
   \   00000E 909F         LD        A, YL
   \   000010 A4 0F        AND       A, #0xf
   \   000012 5F           CLRW      X
   \   000013 5C           INCW      X
   \   000014 CD ....      CALL      L:?sll16_x_x_a
   \   000017 9F           LD        A, XL
   \   000018 B7 ..        LD        S:?b7, A
   1100            /* Get the USART IT index */
   1101            itmask1 = (uint8_t)((uint8_t)USART_IT >> (uint8_t)4);
   \   00001A 909F         LD        A, YL
   \   00001C 4E           SWAP      A
   \   00001D A4 0F        AND       A, #0xf
   \   00001F B7 ..        LD        S:?b5, A
   1102            /* Set the IT mask*/
   1103            itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000021 5F           CLRW      X
   \   000022 5C           INCW      X
   \   000023 B6 ..        LD        A, S:?b5
   \   000025 CD ....      CALL      L:?sll16_x_x_a
   \   000028 9F           LD        A, XL
   \   000029 B7 ..        LD        S:?b6, A
   1104          
   1105            /* Check the status of the specified USART pending bit*/
   1106            if (USART_IT == USART_IT_PE)
   \   00002B 90A3 0100    CPW       Y, #0x100
   \   00002F 26 21        JRNE      L:??USART_GetITStatus_0
   1107            {
   1108              /* Get the USART_IT enable bit status*/
   1109              enablestatus = (uint8_t)((uint8_t)USARTx->CR1 & itmask2);
   \   000031 BE ..        LDW       X, S:?w0
   \   000033 1C 0004      ADDW      X, #0x4
   \   000036 F6           LD        A, (X)
   \   000037 B4 ..        AND       A, S:?b6
   \   000039 B7 ..        LD        S:?b3, A
   1110              /* Check the status of the specified USART interrupt*/
   1111          
   1112              if (((USARTx->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   00003B 92C6 ..      LD        A, [S:?w0.w]
   \   00003E B4 ..        AND       A, S:?b7
   \   000040 A1 00        CP        A, #0x0
   \   000042 27 0A        JREQ      L:??USART_GetITStatus_1
   \   000044 3D ..        TNZ       S:?b3
   \   000046 27 06        JREQ      L:??USART_GetITStatus_1
   1113              {
   1114                /* Interrupt occurred*/
   1115                pendingbitstatus = SET;
   \   000048 A6 01        LD        A, #0x1
   \   00004A B7 ..        LD        S:?b2, A
   \   00004C 20 58        JRA       L:??USART_GetITStatus_2
   1116              }
   1117              else
   1118              {
   1119                /* Interrupt not occurred*/
   1120                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_1:
   \   00004E 3F ..        CLR       S:?b2
   \   000050 20 54        JRA       L:??USART_GetITStatus_2
   1121              }
   1122            }
   1123          
   1124            else if (USART_IT == USART_IT_OR)
   \                     ??USART_GetITStatus_0:
   \   000052 90A3 0235    CPW       Y, #0x235
   \   000056 26 2F        JRNE      L:??USART_GetITStatus_3
   1125            {
   1126              /* Get the USART_IT enable bit status*/
   1127              enablestatus = (uint8_t)((uint8_t)USARTx->CR2 & itmask2);
   \   000058 BE ..        LDW       X, S:?w0
   \   00005A 1C 0005      ADDW      X, #0x5
   \   00005D F6           LD        A, (X)
   \   00005E B4 ..        AND       A, S:?b6
   \   000060 B7 ..        LD        S:?b3, A
   1128              /* Check the status of the specified USART interrupt*/
   1129          
   1130              temp = (uint8_t)(USARTx->CR5 & USART_CR5_EIE);
   \   000062 BE ..        LDW       X, S:?w0
   \   000064 1C 0008      ADDW      X, #0x8
   \   000067 F6           LD        A, (X)
   \   000068 A4 01        AND       A, #0x1
   \   00006A B7 ..        LD        S:?b4, A
   1131          
   1132              if (( (USARTx->SR & itpos) != 0x00) && ((enablestatus || temp)))
   \   00006C 92C6 ..      LD        A, [S:?w0.w]
   \   00006F B4 ..        AND       A, S:?b7
   \   000071 A1 00        CP        A, #0x0
   \   000073 27 0E        JREQ      L:??USART_GetITStatus_4
   \   000075 3D ..        TNZ       S:?b3
   \   000077 26 04        JRNE      L:??USART_GetITStatus_5
   \   000079 3D ..        TNZ       S:?b4
   \   00007B 27 06        JREQ      L:??USART_GetITStatus_4
   1133              {
   1134                /* Interrupt occurred*/
   1135                pendingbitstatus = SET;
   \                     ??USART_GetITStatus_5:
   \   00007D A6 01        LD        A, #0x1
   \   00007F B7 ..        LD        S:?b2, A
   \   000081 20 23        JRA       L:??USART_GetITStatus_2
   1136              }
   1137              else
   1138              {
   1139                /* Interrupt not occurred*/
   1140                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_4:
   \   000083 3F ..        CLR       S:?b2
   \   000085 20 1F        JRA       L:??USART_GetITStatus_2
   1141              }
   1142            }
   1143          
   1144            else
   1145            {
   1146              /* Get the USART_IT enable bit status*/
   1147              enablestatus = (uint8_t)((uint8_t)USARTx->CR2 & itmask2);
   \                     ??USART_GetITStatus_3:
   \   000087 BE ..        LDW       X, S:?w0
   \   000089 1C 0005      ADDW      X, #0x5
   \   00008C F6           LD        A, (X)
   \   00008D B4 ..        AND       A, S:?b6
   \   00008F B7 ..        LD        S:?b3, A
   1148              /* Check the status of the specified USART interrupt*/
   1149              if (((USARTx->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000091 92C6 ..      LD        A, [S:?w0.w]
   \   000094 B4 ..        AND       A, S:?b7
   \   000096 A1 00        CP        A, #0x0
   \   000098 27 0A        JREQ      L:??USART_GetITStatus_6
   \   00009A 3D ..        TNZ       S:?b3
   \   00009C 27 06        JREQ      L:??USART_GetITStatus_6
   1150              {
   1151                /* Interrupt occurred*/
   1152                pendingbitstatus = SET;
   \   00009E A6 01        LD        A, #0x1
   \   0000A0 B7 ..        LD        S:?b2, A
   \   0000A2 20 02        JRA       L:??USART_GetITStatus_2
   1153              }
   1154              else
   1155              {
   1156                /* Interrupt not occurred*/
   1157                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_6:
   \   0000A4 3F ..        CLR       S:?b2
   1158              }
   1159            }
   1160          
   1161            /* Return the USART_IT status*/
   1162            return  pendingbitstatus;
   \                     ??USART_GetITStatus_2:
   \   0000A6 B6 ..        LD        A, S:?b2
   \   0000A8 81           RET
   1163          }
   1164          
   1165          /**
   1166            * @brief  Clears the USARTx’s interrupt pending bits.
   1167            * @param  USARTx: where x can be 1 to select the specified USART peripheral.
   1168            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1169            *         This parameter can be one of the following values:
   1170            *            @arg USART_IT_TC: Transmission complete interrupt.
   1171            * @note   PE (Parity error), FE (Framing error), NE (Noise error),
   1172            *         OR (OverRun error) and IDLE (Idle line detected) pending bits are
   1173            *         cleared by software sequence: a read operation to USART_SR register
   1174            *         (USART_GetITStatus()) followed by a read operation to USART_DR
   1175            *         register (USART_ReceiveData8() or USART_ReceiveData9()).
   1176            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register
   1177            *         (USART_ReceiveData8() or USART_ReceiveData9()).
   1178            * @note   TC (Transmit complete) pending bit can be also cleared by software
   1179            *         sequence: a read operation to USART_SR register (USART_GetITStatus())
   1180            *         followed by a write operation to USART_DR register (USART_SendData8()
   1181            *         or USART_SendData9()).
   1182            * @note   TXE pending bit is cleared only by a write to the USART_DR register
   1183            *         (USART_SendData8() or USART_SendData9()).
   1184            * @retval None
   1185            */

   \                                 In section .near_func.text, align 1
   1186          void USART_ClearITPendingBit(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT)
   1187          {
   1188            assert_param(IS_USART_CLEAR_IT(USART_IT));
   1189          
   1190            /*< Clear RXNE or TC pending bit */
   1191            USARTx->SR &= (uint8_t)(~USART_SR_TC);
   \                     USART_ClearITPendingBit:
   \   000000 F6           LD        A, (X)
   \   000001 A4 BF        AND       A, #0xbf
   \   000003 F7           LD        (X), A
   1192          }
   \   000004 81           RET
   1193          
   1194          
   1195          /**
   1196            * @}
   1197            */
   1198          
   1199          /**
   1200            * @}
   1201            */
   1202          
   1203          /**
   1204            * @}
   1205            */
   1206          
   1207          /**
   1208            * @}
   1209            */
   1210          
   1211          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       5  USART_ClearFlag
       5  USART_ClearITPendingBit
      81  USART_ClockInit
      43  USART_Cmd
      44  USART_DMACmd
      39  USART_DeInit
      53  USART_GetFlagStatus
     169  USART_GetITStatus
      43  USART_HalfDuplexCmd
     148  USART_ITConfig
     207  USART_Init
      43  USART_IrDACmd
      43  USART_IrDAConfig
       3  USART_ReceiveData8
      44  USART_ReceiveData9
      43  USART_ReceiverWakeUpCmd
      18  USART_SendBreak
       6  USART_SendData8
      41  USART_SendData9
      37  USART_SetAddress
       8  USART_SetGuardTime
       8  USART_SetPrescaler
      43  USART_SmartCardCmd
      43  USART_SmartCardNACKCmd
      37  USART_WakeUpConfig

 
 1 254 bytes in section .near_func.text
 
 1 254 bytes of CODE memory

Errors: none
Warnings: none
